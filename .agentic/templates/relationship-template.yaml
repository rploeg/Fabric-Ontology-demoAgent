# Relationship Definition Template
# Use this template when defining relationships between entity types

# Relationship type definition
relationship:
  name: "{relationshipName}"
  description: "{Brief description of what this relationship represents}"
  
  # Source and target entities
  source_entity: "{SourceEntityType}"
  target_entity: "{TargetEntityType}"  # Must be different from source
  
  # Cardinality (for documentation)
  cardinality: "many-to-one"  # Options: one-to-one, one-to-many, many-to-one, many-to-many
  
  # Data binding configuration
  binding:
    table: "{TableContainingRelationship}"
    
    # ⚠️ CRITICAL: source_key_column must be the SOURCE entity's own primary key!
    source_key_column: "{SourceEntity_PrimaryKey}"
    
    # ⚠️ CRITICAL: target_key_column MUST be named EXACTLY the same as the target entity's key!
    # The Fabric API validates this - using a different column name will cause binding to fail.
    target_key_column: "{TargetEntity_KeyName}"  # Must match target's key property name EXACTLY

# =============================================================================
# CRITICAL CONSTRAINT: sourceKeyColumn
# =============================================================================
# 
# The source_key_column MUST be the SOURCE entity's own key, NOT a foreign key.
# This is required because the API validates that sourceKeyRefBindings.targetPropertyId
# must be present in the source entity's entityIdParts array.
# 
# ✓ CORRECT:
#   - source_entity: ProductionBatch
#   - source_key_column: BatchId     (ProductionBatch's OWN key)
#   - target_key_column: ProductId   (FK to Product)
# 
# ✗ WRONG:
#   - source_entity: ProductionBatch
#   - source_key_column: ProductId   (This is a FK, not the source's own key!)
#   - target_key_column: ProductId   (Duplicated - makes no sense)
# 
# API Error for this mistake:
# "sourceKeyRefBindings targetPropertyId 'X' must be present in the source 
#  EntityType's EntityIdParts"

# =============================================================================
# CRITICAL CONSTRAINT: targetKeyColumn Name Must Match Target Entity's Key
# =============================================================================
#
# The Fabric API REQUIRES that target_key_column has the EXACT SAME NAME as
# the target entity's key property. This is a hard validation.
#
# ✓ CORRECT (Facility entity has key "FacilityId"):
#   - target_entity: Facility
#   - target_key_column: FacilityId    # Exact match!
#
# ✗ WRONG:
#   - target_entity: Facility
#   - target_key_column: OriginFacilityId    # Different name - WILL FAIL!
#   - target_key_column: DestFacilityId      # Different name - WILL FAIL!
#
# API Error for this mistake:
# "targetKeyRefBindings targetPropertyId 'OriginFacilityId' must be present 
#  in the target EntityType's EntityIdParts"
#
# SOLUTION: If your table has FK columns with different names (e.g., OriginFacilityId,
# DestFacilityId), create SEPARATE EDGE TABLES with columns renamed to match:
#
#   EdgeShipmentOrigin.csv:      ShipmentId, FacilityId  (not OriginFacilityId)
#   EdgeShipmentDestination.csv: ShipmentId, FacilityId  (not DestFacilityId)

# =============================================================================
# Relationship Naming Convention
# =============================================================================
# Use distinct names for different edge types.
# Format: {verb}{TargetNoun} in camelCase
# 
# Examples:
#   - producedAs (ProductionBatch → Product)
#   - usesComponent (ProductionBatch → Component)
#   - suppliedBy (Component → Supplier)
#   - locatedAt (ProductionBatch → Facility)

# =============================================================================
# Table Selection
# =============================================================================
# 
# Many-to-One (FK in source table):
#   - Table: Source entity's dimension table
#   - Example: ProductionBatch → Product uses DimProductionBatch
# 
# Many-to-Many (junction table):
#   - Table: Fact/junction table with both FKs
#   - Example: ProductionBatch → Component uses FactBatchComponent

# =============================================================================
# Example: Many-to-One Relationship
# =============================================================================
example_many_to_one:
  relationship:
    name: producedAs
    description: "Links a production batch to the product it manufactures"
    
    source_entity: ProductionBatch
    target_entity: Product
    cardinality: many-to-one  # Many batches can produce one product
    
    binding:
      table: DimProductionBatch  # FK is in the source entity's table
      source_key_column: BatchId     # ✓ ProductionBatch's OWN key
      target_key_column: ProductId   # ✓ FK to Product

# =============================================================================
# Example: Many-to-Many Relationship
# =============================================================================
example_many_to_many:
  relationship:
    name: usesComponent
    description: "Links production batches to components used in manufacturing"
    
    source_entity: ProductionBatch
    target_entity: Component
    cardinality: many-to-many  # Many batches use many components
    
    binding:
      table: FactBatchComponent  # Junction table with both FKs
      source_key_column: BatchId       # ✓ ProductionBatch's OWN key
      target_key_column: ComponentId   # ✓ FK to Component
